import fs from 'node:fs';
import { resolve, isAbsolute } from 'node:path';
import { ClassGenerator, defaultMangleClassFilter, splitCode, makeRegex } from '@tailwindcss-mangle/shared';
export { ClassGenerator } from '@tailwindcss-mangle/shared';
import { getConfig } from '@tailwindcss-mangle/config';
import { sort } from 'fast-sort';
import micromatch from 'micromatch';
import postcss from 'postcss';
import parser from 'postcss-selector-parser';
import { html, defaultTreeAdapter, parse, serialize } from 'parse5';
import babel, { transformSync as transformSync$1 } from '@babel/core';
import { declare } from '@babel/helper-plugin-utils';
import MagicString from 'magic-string';
import { jsStringEscape } from '@ast-core/escape';



// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);
function isObject(value) {
  return value !== null && typeof value === "object";
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isObject(value) && isObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();

const { isMatch } = micromatch;
function escapeStringRegexp(str) {
  if (typeof str !== "string") {
    throw new TypeError("Expected a string");
  }
  return str.replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&").replaceAll("-", "\\x2d");
}
function createGlobMatcher(pattern, fallbackValue = false) {
  if (pattern === void 0) {
    return function() {
      return fallbackValue;
    };
  }
  return function(file) {
    return isMatch(file, pattern);
  };
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Context {
  constructor() {
    __publicField(this, "options");
    __publicField(this, "includeMatcher");
    __publicField(this, "excludeMatcher");
    __publicField(this, "replaceMap");
    __publicField(this, "classSet");
    __publicField(this, "classGenerator");
    __publicField(this, "preserveFunctionSet");
    __publicField(this, "preserveClassNamesSet");
    __publicField(this, "preserveFunctionRegexs");
    this.options = {};
    this.classSet = /* @__PURE__ */ new Set();
    this.replaceMap = /* @__PURE__ */ new Map();
    this.includeMatcher = () => true;
    this.excludeMatcher = () => false;
    this.classGenerator = new ClassGenerator();
    this.preserveFunctionSet = /* @__PURE__ */ new Set();
    this.preserveClassNamesSet = /* @__PURE__ */ new Set();
    this.preserveFunctionRegexs = [];
  }
  isPreserveClass(className) {
    return this.preserveClassNamesSet.has(className);
  }
  addPreserveClass(className) {
    return this.preserveClassNamesSet.add(className);
  }
  isPreserveFunction(calleeName) {
    return this.preserveFunctionSet.has(calleeName);
  }
  mergeOptions(...opts) {
    this.options = defu(this.options, ...opts);
    this.includeMatcher = createGlobMatcher(this.options.include, true);
    this.excludeMatcher = createGlobMatcher(this.options.exclude, false);
    this.classGenerator = new ClassGenerator(this.options.classGenerator);
    this.preserveFunctionSet = new Set(this.options?.preserveFunction ?? []);
    this.preserveFunctionRegexs = [...this.preserveFunctionSet.values()].map((x) => {
      return new RegExp(escapeStringRegexp(x) + "\\(([^)]*)\\)", "g");
    });
  }
  isInclude(file) {
    return this.includeMatcher(file) && !this.excludeMatcher(file);
  }
  currentMangleClassFilter(className) {
    return (this.options.mangleClassFilter ?? defaultMangleClassFilter)(className);
  }
  getClassSet() {
    return this.classSet;
  }
  getReplaceMap() {
    return this.replaceMap;
  }
  addToUsedBy(key, file) {
    const hit = this.classGenerator.newClassMap[key];
    if (hit) {
      hit.usedBy.add(file);
    }
  }
  loadClassSet(classList) {
    const list = sort(classList).desc((c) => c.length);
    for (const className of list) {
      if (this.currentMangleClassFilter(className)) {
        this.classSet.add(className);
      }
    }
  }
  async initConfig(opts = {}) {
    const { cwd, classList: _classList, mangleOptions } = opts;
    const { config, cwd: configCwd } = await getConfig(cwd);
    this.mergeOptions(mangleOptions, config?.mangle);
    if (_classList) {
      this.loadClassSet(_classList);
    } else {
      let jsonPath = this.options.classListPath ?? resolve(process.cwd(), config?.patch?.output?.filename);
      if (!isAbsolute(jsonPath)) {
        jsonPath = resolve(configCwd ?? process.cwd(), jsonPath);
      }
      if (jsonPath && fs.existsSync(jsonPath)) {
        const rawClassList = fs.readFileSync(jsonPath, "utf8");
        const list = JSON.parse(rawClassList);
        this.loadClassSet(list);
      }
    }
    for (const cls of this.classSet) {
      this.classGenerator.generateClassName(cls);
    }
    for (const x of Object.entries(this.classGenerator.newClassMap)) {
      this.replaceMap.set(x[0], x[1].name);
    }
    return config;
  }
  // ["clsx\\(([^)]*)\\)", "(?:'|\"|`)([^']*)(?:'|\"|`)"]
}

const postcssPlugin = "postcss-mangle-tailwindcss-plugin";
const clonedKey = "__tw_mangle_cloned__";
function isVueScoped(s) {
  if (s.parent) {
    const index = s.parent.nodes.indexOf(s);
    if (index > -1) {
      const nextNode = s.parent.nodes[index + 1];
      if (nextNode && nextNode.type === "attribute" && nextNode.attribute.includes("data-v-")) {
        return true;
      }
    }
  }
  return false;
}
const transformSelectorPostcssPlugin = function(options) {
  const { ignoreVueScoped, replaceMap, ctx } = defu(options, {
    ignoreVueScoped: true
  });
  return {
    postcssPlugin,
    async Rule(rule) {
      if (rule[clonedKey]) {
        return;
      }
      await parser((selectors) => {
        selectors.walkClasses((s) => {
          if (s.value && replaceMap && replaceMap.has(s.value)) {
            if (ignoreVueScoped && isVueScoped(s)) {
              return;
            }
            const v = replaceMap.get(s.value);
            if (v) {
              if (ctx.isPreserveClass(s.value)) {
                const r = rule.cloneBefore();
                r[clonedKey] = true;
              }
              s.value = v;
            }
          }
        });
      }).transform(rule, {
        lossless: false,
        updateSelector: true
      });
    }
  };
};
transformSelectorPostcssPlugin.postcss = true;

function cssHandler(rawSource, options) {
  const acceptedPlugins = [transformSelectorPostcssPlugin(options)];
  const { file } = options;
  return postcss(acceptedPlugins).process(rawSource, {
    from: file,
    to: file
  });
}

({
    HTML: html.NS.HTML,
    XML: html.NS.XML,
    MATHML: html.NS.MATHML,
    SVG: html.NS.SVG,
    XLINK: html.NS.XLINK,
    XMLNS: html.NS.XMLNS
});

/**
 * Determines if a given node is a document or not
 * @param {Node} node Node to test
 * @return {boolean}
 */
function isDocument(node) {
    return node.nodeName === '#document';
}
/**
 * Determines if a given node is a document fragment or not
 * @param {Node} node Node to test
 * @return {boolean}
 */
function isDocumentFragment(node) {
    return node.nodeName === '#document-fragment';
}
/**
 * Determines if a given node is a template node or not
 * @param {Node} node Node to test
 * @return {boolean}
 */
function isTemplateNode(node) {
    return node.nodeName === 'template';
}
const isElementNode = defaultTreeAdapter.isElementNode;
const isCommentNode = defaultTreeAdapter.isCommentNode;
const isDocumentTypeNode = defaultTreeAdapter.isDocumentTypeNode;
const isTextNode = defaultTreeAdapter.isTextNode;
/**
 * Determines if a given node is a parent or not
 * @param {Node} node Node to test
 * @return {boolean}
 */
function isParentNode(node) {
    return (isDocument(node) ||
        isDocumentFragment(node) ||
        isElementNode(node) ||
        isTemplateNode(node));
}

defaultTreeAdapter.appendChild;

/**
 * Traverses the tree of a given node
 * @param {Node} node Node to traverse
 * @param {Visitor} visitor Visitor to apply
 * @param {ParentNode=} parent Parent node of the current node
 * @return {void}
 */
function traverse(node, visitor, parent) {
    const shouldVisitChildren = typeof visitor['pre:node'] !== 'function' ||
        visitor['pre:node'](node, parent) !== false;
    if (shouldVisitChildren && isParentNode(node)) {
        for (const child of node.childNodes) {
            traverse(child, visitor, node);
        }
    }
    if (typeof visitor.node === 'function') {
        visitor.node(node, parent);
    }
    if (typeof visitor.document === 'function' && isDocument(node)) {
        visitor.document(node);
    }
    if (typeof visitor.documentFragment === 'function' &&
        isDocumentFragment(node)) {
        visitor.documentFragment(node, parent);
    }
    if (typeof visitor.element === 'function' && isElementNode(node)) {
        visitor.element(node, parent);
    }
    if (typeof visitor.template === 'function' && isTemplateNode(node)) {
        visitor.template(node, parent);
    }
    if (typeof visitor.comment === 'function' && isCommentNode(node)) {
        visitor.comment(node, parent);
    }
    if (typeof visitor.text === 'function' && isTextNode(node)) {
        visitor.text(node, parent);
    }
    if (typeof visitor.documentType === 'function' && isDocumentTypeNode(node)) {
        visitor.documentType(node, parent);
    }
}

function htmlHandler(rawSource, options) {
  const { replaceMap, ctx } = options;
  const fragment = parse(rawSource);
  traverse(fragment, {
    element(node) {
      const attribute = node.attrs.find((x) => x.name === "class");
      if (attribute) {
        const array = splitCode(attribute.value, {
          splitQuote: false
        });
        for (const v of array) {
          if (replaceMap.has(v)) {
            attribute.value = attribute.value.replace(makeRegex(v), ctx.classGenerator.generateClassName(v).name);
          }
        }
      }
    }
  });
  return serialize(fragment);
}

const isProd = () => process.env.NODE_ENV === "production";

function between(x, min, max, included = false) {
  if (typeof x !== "number") {
    return false;
  }
  return included ? x >= min && x <= max : x > min && x < max;
}

function handleValue$1(options) {
  const { ctx, id, path, magicString, raw, replaceMap, offset = 0, escape = false, markedArray } = options;
  const node = path.node;
  let value = raw;
  for (const [s, e] of markedArray) {
    if (between(node.start, s, e) || between(node.end, s, e)) {
      return;
    }
  }
  const arr = sort(splitCode(value)).desc((x) => x.length);
  for (const str of arr) {
    if (replaceMap.has(str)) {
      ctx.addToUsedBy(str, id);
      const v = replaceMap.get(str);
      if (v) {
        value = value.replaceAll(str, v);
      }
    }
  }
  if (typeof node.start === "number" && typeof node.end === "number" && value) {
    const start = node.start + offset;
    const end = node.end - offset;
    if (start < end) {
      magicString.update(start, end, escape ? jsStringEscape(value) : value);
    }
  }
}
const JsPlugin = declare((api, options) => {
  api.assertVersion(7);
  const { magicString, replaceMap, id, ctx, markedArray } = options;
  return {
    visitor: {
      StringLiteral: {
        exit(p) {
          const opts = {
            ctx,
            id,
            magicString,
            path: p,
            raw: p.node.value,
            replaceMap,
            offset: 1,
            escape: true,
            markedArray
          };
          handleValue$1(opts);
        }
      },
      TemplateElement: {
        exit(p) {
          const opts = {
            ctx,
            id,
            magicString,
            path: p,
            raw: p.node.value.raw,
            replaceMap,
            offset: 0,
            escape: false,
            markedArray
          };
          handleValue$1(opts);
        }
      }
    }
  };
});
function transformSync(ast, code, plugins, filename) {
  babel.transformFromAstSync(ast, code, {
    presets: loadPresets(),
    plugins,
    filename
  });
}
function loadPresets() {
  return [
    [
      require("@babel/preset-typescript"),
      {
        allExtensions: true,
        isTSX: true
      }
    ]
  ];
}
function preProcessJs(options) {
  const { code, replaceMap, id, ctx } = options;
  const magicString = typeof code === "string" ? new MagicString(code) : code;
  let ast;
  try {
    const file = babel.parseSync(magicString.original, {
      sourceType: "unambiguous",
      presets: loadPresets()
    });
    if (file) {
      ast = file;
    } else {
      return code.toString();
    }
  } catch {
    return code.toString();
  }
  const markedArray = [];
  babel.traverse(ast, {
    CallExpression: {
      enter(p) {
        const callee = p.get("callee");
        if (callee.isIdentifier() && ctx.isPreserveFunction(callee.node.name)) {
          if (p.node.start && p.node.end) {
            markedArray.push([p.node.start, p.node.end]);
          }
          p.traverse({
            StringLiteral: {
              enter(path) {
                const node = path.node;
                const value = node.value;
                const arr = sort(splitCode(value)).desc((x) => x.length);
                for (const str of arr) {
                  if (replaceMap.has(str)) {
                    ctx.addPreserveClass(str);
                  }
                }
              }
            },
            TemplateElement: {
              enter(path) {
                const node = path.node;
                const value = node.value.raw;
                const arr = sort(splitCode(value)).desc((x) => x.length);
                for (const str of arr) {
                  if (replaceMap.has(str)) {
                    ctx.addPreserveClass(str);
                  }
                }
              }
            }
          });
        }
      }
    }
  });
  transformSync(
    ast,
    magicString.original,
    [
      [
        JsPlugin,
        {
          magicString,
          replaceMap,
          id,
          ctx,
          markedArray
        }
      ]
    ],
    id
  );
  return magicString.toString();
}
function preProcessRawCode(options) {
  const { code, replaceMap, ctx } = options;
  const magicString = typeof code === "string" ? new MagicString(code) : code;
  const markArr = [];
  for (const regex of ctx.preserveFunctionRegexs) {
    const allArr = [];
    let arr = null;
    while ((arr = regex.exec(magicString.original)) !== null) {
      allArr.push(arr);
      markArr.push([arr.index, arr.index + arr[0].length]);
    }
    for (const regExpMatch of allArr) {
      let ast;
      try {
        ast = babel.parseSync(regExpMatch[0], {
          sourceType: "unambiguous"
        });
        ast && babel.traverse(ast, {
          StringLiteral: {
            enter(p) {
              const arr2 = sort(splitCode(p.node.value)).desc((x) => x.length);
              for (const v of arr2) {
                if (replaceMap.has(v)) {
                  ctx.addPreserveClass(v);
                }
              }
            }
          },
          TemplateElement: {
            enter(p) {
              const arr2 = sort(splitCode(p.node.value.raw)).desc((x) => x.length);
              for (const v of arr2) {
                if (replaceMap.has(v)) {
                  ctx.addPreserveClass(v);
                }
              }
            }
          }
        });
      } catch {
        continue;
      }
    }
  }
  for (const [key, value] of replaceMap) {
    const regex = new RegExp(escapeStringRegexp(key), "g");
    let arr = null;
    while ((arr = regex.exec(magicString.original)) !== null) {
      const start = arr.index;
      const end = arr.index + arr[0].length;
      let shouldUpdate = true;
      for (const [ps, pe] of markArr) {
        if (between(start, ps, pe) || between(end, ps, pe)) {
          shouldUpdate = false;
          break;
        }
      }
      if (shouldUpdate) {
        magicString.update(start, end, value);
        markArr.push([start, end]);
      }
    }
  }
  return magicString.toString();
}

function handleValue(raw, node, options) {
  const { replaceMap, ctx, splitQuote = true } = options;
  const clsGen = ctx.classGenerator;
  const array = splitCode(raw, {
    splitQuote
  });
  let rawString = raw;
  for (const v of array) {
    if (replaceMap.has(v)) {
      let ignoreFlag = false;
      if (Array.isArray(node.leadingComments)) {
        ignoreFlag = node.leadingComments.findIndex((x) => x.value.includes("tw-mangle") && x.value.includes("ignore")) > -1;
      }
      if (!ignoreFlag) {
        rawString = rawString.replace(makeRegex(v), clsGen.generateClassName(v).name);
      }
    }
  }
  return rawString;
}
function jsHandler(rawSource, options) {
  const result = transformSync$1(rawSource, {
    babelrc: false,
    ast: true,
    plugins: [
      () => {
        return {
          visitor: {
            StringLiteral: {
              enter(p) {
                const n = p.node;
                n.value = handleValue(n.value, n, options);
              }
            },
            TemplateElement: {
              enter(p) {
                const n = p.node;
                n.value.raw = handleValue(n.value.raw, n, options);
              }
            },
            CallExpression: {
              enter(p) {
                const calleePath = p.get("callee");
                if (calleePath.isIdentifier() && calleePath.node.name === "eval") {
                  p.traverse({
                    StringLiteral: {
                      enter(s) {
                        const res = jsHandler(s.node.value, options);
                        if (res.code) {
                          s.node.value = res.code;
                        }
                      }
                    }
                  });
                }
              }
            }
            // noScope: true
          }
        };
      }
    ],
    minified: options.minified ?? isProd(),
    sourceMaps: false,
    configFile: false
  });
  return result;
}

export { Context, cssHandler, handleValue, htmlHandler, jsHandler, preProcessJs, preProcessRawCode };

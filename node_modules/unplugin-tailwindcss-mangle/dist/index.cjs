'use strict';

const path = require('node:path');
const fs = require('node:fs/promises');
const unplugin$1 = require('unplugin');
const core = require('@tailwindcss-mangle/core');
const MagicString = require('magic-string');
const utils = require('./shared/unplugin-tailwindcss-mangle.43bd55b2.cjs');
require('@tailwindcss-mangle/shared');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
const MagicString__default = /*#__PURE__*/_interopDefaultCompat(MagicString);

const unplugin = unplugin$1.createUnplugin((options) => {
  const ctx = new core.Context();
  return {
    name: utils.pluginName,
    enforce: "pre",
    async buildStart() {
      await ctx.initConfig({
        mangleOptions: options
      });
    },
    transformInclude(id) {
      return ctx.isInclude(id);
    },
    transform(code, id) {
      const s = new MagicString__default(code);
      const replaceMap = ctx.getReplaceMap();
      return /\.[jt]sx?$/.test(id) ? core.preProcessJs({
        code: s,
        replaceMap,
        ctx,
        id
      }) : core.preProcessRawCode({
        code,
        ctx,
        replaceMap,
        id
      });
    },
    vite: {
      generateBundle: {
        async handler(options2, bundle) {
          const replaceMap = ctx.getReplaceMap();
          const groupedEntries = utils.getGroupedEntries(Object.entries(bundle));
          if (Array.isArray(groupedEntries.css) && groupedEntries.css.length > 0) {
            for (let i = 0; i < groupedEntries.css.length; i++) {
              const [file, cssSource] = groupedEntries.css[i];
              const { css } = await core.cssHandler(cssSource.source.toString(), {
                file,
                replaceMap,
                ctx
              });
              cssSource.source = css;
            }
          }
        }
      }
    },
    webpack(compiler) {
      const { Compilation, sources } = compiler.webpack;
      const { ConcatSource } = sources;
      compiler.hooks.compilation.tap(utils.pluginName, (compilation) => {
        compilation.hooks.processAssets.tapPromise(
          {
            name: utils.pluginName,
            stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE
          },
          async (assets) => {
            const replaceMap = ctx.getReplaceMap();
            const groupedEntries = utils.getGroupedEntries(Object.entries(assets));
            if (groupedEntries.js.length > 0) {
              for (let i = 0; i < groupedEntries.js.length; i++) {
                const [file, chunk] = groupedEntries.js[i];
                const code = core.jsHandler(chunk.source().toString(), {
                  replaceMap,
                  ctx
                }).code;
                if (code) {
                  const source = new ConcatSource(code);
                  compilation.updateAsset(file, source);
                }
              }
            }
            if (groupedEntries.css.length > 0) {
              for (let i = 0; i < groupedEntries.css.length; i++) {
                const [file, cssSource] = groupedEntries.css[i];
                const { css } = await core.cssHandler(cssSource.source().toString(), {
                  replaceMap,
                  file,
                  ctx
                });
                const source = new ConcatSource(css);
                compilation.updateAsset(file, source);
              }
            }
            if (groupedEntries.html.length > 0) {
              for (let i = 0; i < groupedEntries.html.length; i++) {
                const [file, asset] = groupedEntries.html[i];
                const html = core.htmlHandler(asset.source().toString(), {
                  ctx,
                  replaceMap
                });
                const source = new ConcatSource(html);
                compilation.updateAsset(file, source);
              }
            }
          }
        );
      });
    },
    async writeBundle() {
      if (ctx.options.classMapOutput?.enable) {
        const opts = ctx.options.classMapOutput;
        const entries = Object.entries(ctx.classGenerator.newClassMap);
        if (entries.length > 0 && opts) {
          await utils.ensureDir(path.dirname(opts.filename));
          const output = JSON.stringify(
            entries.map((x) => {
              return {
                origin: x[0],
                replacement: x[1].name,
                usedBy: [...x[1].usedBy]
              };
            }),
            null,
            opts.loose ? 2 : 0
          );
          await fs__default.writeFile(opts.filename, output, "utf8");
          console.log(`\u2728 ${opts.filename} generated!`);
        }
      }
    }
  };
});

module.exports = unplugin;
